[33mcommit a23fb5446ca9606116cbe0b9e9f434fd55432417[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mmaster[m[33m)[m
Author: Shaikh Abdul Rehman <sar281924@gmail.com>
Date:   Thu Oct 23 18:24:26 2025 +0500

    Initial commit of server_alert.py

[1mdiff --git a/server_alert.py b/server_alert.py[m
[1mnew file mode 100644[m
[1mindex 0000000..8863807[m
[1m--- /dev/null[m
[1m+++ b/server_alert.py[m
[36m@@ -0,0 +1,631 @@[m
[32m+[m[32m #usr/bin/env python3[m
[32m+[m[32m"""//Server Protector Bot[m
[32m+[m[32mOverview[m
[32m+[m[32m--------[m
[32m+[m[32mThis module implements an asynchronous "Server Protector" monitoring bot for Linux/Ubuntu[m
[32m+[m[32mservers. It continuously watches system logs and metrics, detects suspicious activity,[m
[32m+[m[32mand sends batched, rate-limited alerts to an administrator via Telegram.[m
[32m+[m[32mKey features[m
[32m+[m[32m------------[m
[32m+[m[32m- Tails /var/log/auth.log (and optionally Postgres logs) to detect SSH events:[m
[32m+[m[32m    failed logins, invalid user attempts, accepted logins (including root) and sudo events.[m
[32m+[m[32m- Periodic resource monitoring: CPU, memory, disk usage.[m
[32m+[m[32m- Network monitoring: per-interface throughput vs. link speed.[m
[32m+[m[32m- Periodic port scanning on configured hosts/ports (with optional range).[m
[32m+[m[32m- Ping/host reachability checks for configured hosts.[m
[32m+[m[32m- Public IP detection and change alerts using an external IP service.[m
[32m+[m[32m- Suspicious process detection (heuristics for tools like netcat, socat).[m
[32m+[m[32m- Aggregates alerts into a single summary message at configurable intervals.[m
[32m+[m[32m- Per-alert-text cooldowns to prevent spamming the admin.[m
[32m+[m[32m- Telegram bot commands and inline buttons for status, quick scans, snoozing, and tailing logs.[m
[32m+[m[32mImportant configuration points (defined as module-level constants)[m
[32m+[m[32m------------------------------------------------------------------[m
[32m+[m[32m- TELEGRAM_BOT_TOKEN: Telegram bot token (sensitive, keep secret).[m
[32m+[m[32m- ADMIN_TELEGRAM_ID: Telegram numeric user id of administrator to receive alerts.[m
[32m+[m[32m- AUTH_LOG, PG_LOG: file paths to monitor (auth.log is the primary SSH/auth log).[m
[32m+[m[32m- Thresholds: CPU_THRESHOLD, MEM_THRESHOLD, DISK_THRESHOLD, NET_THRESHOLD.[m
[32m+[m[32m- FAILED_ATTEMPT_WINDOW and FAILED_ATTEMPT_LIMIT: brute-force detection window and limit.[m
[32m+[m[32m- PORTS_TO_SCAN, PORT_RANGE, PORT_SCAN_CONCURRENT, PORT_SCAN_INTERVAL: port scanning controls.[m
[32m+[m[32m- PING_HOSTS: list of hosts/IPs to ping for reachability checks.[m
[32m+[m[32m- SUMMARY_INTERVAL and ALERT_COOLDOWN: batching and rate-limiting of alerts.[m
[32m+[m[32m- PUBLIC_IP_URL and PUBLIC_IP_CHECK_INTERVAL: public IP checking.[m
[32m+[m[32mAsync tasks / Primary functions[m
[32m+[m[32m-------------------------------[m
[32m+[m[32m- main(): boots the Telegram Application, registers handlers and schedules background tasks.[m
[32m+[m[32m- tail_log_loop(path, line_handler): asynchronous tail/follow implementation for files.[m
[32m+[m[32m- handle_auth_line(line): parses auth.log lines to detect failed/invalid/accepted logins and sudo events.[m
[32m+[m[32m- resource_monitor_loop(application): polls CPU/memory/disk and generates alerts if thresholds exceeded.[m
[32m+[m[32m- network_monitor_loop(application): measures interface throughput and compares it to link speed.[m
[32m+[m[32m- port_scan_loop(application, hosts, ports, port_range): scans ports and reports open ones.[m
[32m+[m[32m- ping_loop(application, hosts): pings configured hosts and alerts when unreachable.[m
[32m+[m[32m- public_ip_loop(application): checks public IP and alerts on change.[m
[32m+[m[32m- suspicious_process_loop(application): inspects running processes for known suspicious commands.[m
[32m+[m[32m- send_summary_if_due(application): sends the batched alert summary to the admin if the summary interval elapsed.[m
[32m+[m[32m- add_pending(msg) and rate_limited_alert(text): helpers for adding alerts with per-text cooldowns.[m
[32m+[m[32mTelegram interaction[m
[32m+[m[32m--------------------[m
[32m+[m[32m- Commands implemented: /status, /snooze <mins>, /tail [file], /scan, /ports, /help[m
[32m+[m[32m- Inline keyboard buttons offer quick actions: show system status, snooze alerts,[m
[32m+[m[32m    show last log lines, and run a local port scan.[m
[32m+[m[32m- Admin-only commands are enforced by checking update.effective_user.id against ADMIN_TELEGRAM_ID.[m
[32m+[m[32mSecurity & operational notes[m
[32m+[m[32m----------------------------[m
[32m+[m[32m- The bot requires read access to monitored log files (e.g. /var/log/auth.log). On most systems[m
[32m+[m[32m    this needs root or group access (e.g., adm). Run with appropriate privileges or adjust file ACLs.[m
[32m+[m[32m- Keep TELEGRAM_BOT_TOKEN secret. Do not commit it to source control.[m
[32m+[m[32m- Port scanning can be intrusive or trigger IDS — configure ranges and scan frequency responsibly.[m
[32m+[m[32m- The module performs network operations and spawns concurrent tasks; monitor resource usage if run on constrained systems.[m
[32m+[m[32m- Rate limiting and summary batching are implemented to reduce alert noise; tune SUMMARY_INTERVAL and ALERT_COOLDOWN as needed.[m
[32m+[m[32mDependencies[m
[32m+[m[32m------------[m
[32m+[m[32m- Python 3.8+[m
[32m+[m[32m- asyncio (stdlib)[m
[32m+[m[32m- python-telegram-bot (v20+ async API)[m
[32m+[m[32m- psutil[m
[32m+[m[32m- aiohttp[m
[32m+[m[32m- nest_asyncio (used to allow nested loops in some runtimes)[m
[32m+[m[32m- requests (used in some utility paths)[m
[32m+[m[32m- socket (stdlib)[m
[32m+[m[32mUsage[m
[32m+[m[32m-----[m
[32m+[m[32mRun the module directly on the target server:[m
[32m+[m[32m        python server_alert.py[m
[32m+[m[32mEnsure TELEGRAM_BOT_TOKEN and ADMIN_TELEGRAM_ID are correctly configured in the module[m
[32m+[m[32m(or refactor to use environment variables/config file for production deployments).[m
[32m+[m[32mExtensibility[m
[32m+[m[32m-------------[m
[32m+[m[32m- Add or change monitored log files by updating AUTH_LOG/PG_LOG or registering additional tails.[m
[32m+[m[32m- Extend suspicious process heuristics by updating SUSPICIOUS_PROCESSES.[m
[32m+[m[32m- Add custom alert handlers to react to particular log patterns or metric thresholds.[m
[32m+[m[32m- Replace hard-coded configuration with environment variables or a config file for safer deployment.[m
[32m+[m[32mLicense and privacy[m
[32m+[m[32m-------------------[m
[32m+[m[32mThis module sends operational data (alerts and summaries) to the configured Telegram admin.[m
[32m+[m[32mBe mindful of sensitive information included in alerts. Remove or redact secrets before[m
[32m+[m[32msending logs or process command-lines. Ensure compliance with your organization's privacy policy."""[m
[32m+[m[32m"""[m
[32m+[m[32mserver_alert.py[m
[32m+[m
[32m+[m
[32m+[m[32mServer Protector Bot - Ubuntu/Linux[m
[32m+[m[32mMonitors SSH auth.log, Postgres log, system resources, network, ports, processes,[m
[32m+[m[32mpublic IP, and sends alerts via Telegram (batched + rate-limited).[m
[32m+[m[32m"""[m
[32m+[m
[32m+[m
[32m+[m[32mimport os[m
[32m+[m[32mimport re[m
[32m+[m[32mimport time[m
[32m+[m[32mimport socket[m
[32m+[m[32mimport asyncio[m
[32m+[m[32mimport nest_asyncio[m
[32m+[m[32mimport psutil[m
[32m+[m[32mimport aiohttp[m
[32m+[m[32mimport requests[m
[32m+[m[32mfrom datetime import datetime, timedelta[m
[32m+[m[32mfrom collections import defaultdict, deque[m
[32m+[m[32mfrom telegram import InlineKeyboardButton, InlineKeyboardMarkup[m
[32m+[m[32mfrom telegram.ext import CallbackQueryHandler[m
[32m+[m
[32m+[m[32mfrom telegram import Bot, Update[m
[32m+[m[32mfrom telegram.ext import ([m
[32m+[m[32m    ApplicationBuilder,[m
[32m+[m[32m    CommandHandler,[m
[32m+[m[32m    ContextTypes,[m
[32m+[m[32m)[m
[32m+[m
[32m+[m[32mnest_asyncio.apply()[m
[32m+[m
[32m+[m[32m# ---------------- CONFIG ----------------[m
[32m+[m[32mTELEGRAM_BOT_TOKEN = "8247876511:AAHw_TudiZ4UntTGjbHYAugLY30WKr1WIkg"[m
[32m+[m[32mADMIN_TELEGRAM_ID = 8498390933[m
[32m+[m
[32m+[m
[32m+[m[32m# Files & system paths (Ubuntu)[m
[32m+[m[32mAUTH_LOG = "/var/log/auth.log"                      # SSH/auth log[m
[32m+[m[32mPG_LOG = "/var/log/postgresql/postgresql.log"       # optional[m
[32m+[m[32m# Monitoring thresholds[m
[32m+[m[32mCPU_THRESHOLD = 5.0    # percent[m
[32m+[m[32mMEM_THRESHOLD = 5.0    # percent[m
[32m+[m[32mDISK_THRESHOLD = 5.0   # percent[m
[32m+[m[32mNET_THRESHOLD = 5.0    # percent of link speed[m
[32m+[m[32mFAILED_ATTEMPT_WINDOW = 300  # seconds (5 min)[m
[32m+[m[32mFAILED_ATTEMPT_LIMIT = 5[m
[32m+[m
[32m+[m
[32m+[m[32m# Port scan configuration[m
[32m+[m[32mPORTS_TO_SCAN = [22, 80, 443,5432]  # default ports[m
[32m+[m[32mPORT_RANGE = (1, 1024)         # if you want full range scanning (slow)[m
[32m+[m[32mPORT_SCAN_CONCURRENT = 200[m
[32m+[m
[32m+[m
[32m+[m[32m# Ping / host checks (add hosts/IPs you care about)[m
[32m+[m[32mPING_HOSTS = ["127.0.0.1"]     # add remote servers or services[m
[32m+[m
[32m+[m
[32m+[m[32m# Summary & rate-limiting[m
[32m+[m[32mSUMMARY_INTERVAL = 60          # seconds between summary messages (1 min)[m
[32m+[m[32mALERT_COOLDOWN = 20            # per unique alert text cooldown (seconds)[m
[32m+[m
[32m+[m
[32m+[m[32m# Public IP check[m
[32m+[m[32mPUBLIC_IP_URL = "https://api.ipify.org?format=text"[m
[32m+[m[32mPUBLIC_IP_CHECK_INTERVAL = 120[m
[32m+[m
[32m+[m
[32m+[m[32m# Other[m
[32m+[m[32mCHECK_INTERVAL = 5             # main "fast" loop tick seconds[m
[32m+[m[32mPORT_SCAN_INTERVAL = 300       # how often to run port scan (seconds)[m
[32m+[m[32mSUSPICIOUS_PROCESSES = ["nc", "ncat", "netcat", "socat"]  # heuristics[m
[32m+[m[32m# ---------------------------------------[m
[32m+[m
[32m+[m
[32m+[m[32m# State[m
[32m+[m[32mpending_alerts = []                 # list[str][m
[32m+[m[32mlast_alert_time_for_text = defaultdict(lambda: datetime.min)[m
[32m+[m[32mfailed_attempts_by_ip = defaultdict(lambda: deque())[m
[32m+[m[32mlast_summary_time = 0[m
[32m+[m[32mlast_public_ip = None[m
[32m+[m
[32m+[m
[32m+[m[32mbot = Bot(token=TELEGRAM_BOT_TOKEN)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Utilities --------------------[m
[32m+[m[32mdef rate_limited_alert(text: str) -> bool:[m
[32m+[m[32m    """Return True if allowed; otherwise False (cooldown active)."""[m
[32m+[m[32m    now = datetime.utcnow()[m
[32m+[m[32m    last = last_alert_time_for_text.get(text, datetime.min)[m
[32m+[m[32m    if (now - last).total_seconds() < ALERT_COOLDOWN:[m
[32m+[m[32m        return False[m
[32m+[m[32m    last_alert_time_for_text[text] = now[m
[32m+[m[32m    return True[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mdef add_pending(msg: str):[m
[32m+[m[32m    """Add a message to the pending summary if not duplicate and rate-allowed."""[m
[32m+[m[32m    if not rate_limited_alert(msg):[m
[32m+[m[32m        return[m
[32m+[m[32m    pending_alerts.append(f"{datetime.utcnow().isoformat()} - {msg}")[m
[32m+[m[32m    print("[PENDING]", msg)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32masync def send_summary_if_due(application):[m
[32m+[m[32m    """If summary interval elapsed, send a single summary message with all pending alerts."""[m
[32m+[m[32m    global last_summary_time, pending_alerts[m
[32m+[m[32m    now = time.time()[m
[32m+[m[32m    if now - last_summary_time < SUMMARY_INTERVAL:[m
[32m+[m[32m        return[m
[32m+[m[32m    if not pending_alerts:[m
[32m+[m[32m        last_summary_time = now[m
[32m+[m[32m        return[m
[32m+[m[32m    body = "📋 <b>Server Alert Summary</b>\n\n" + "\n\n".join(pending_alerts)[m
[32m+[m[32m    try:[m
[32m+[m[32m        await application.bot.send_message(chat_id=ADMIN_TELEGRAM_ID, text=body, parse_mode="HTML")[m
[32m+[m[32m        print("[SENT SUMMARY]", len(pending_alerts), "items")[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        print("[ERROR] sending summary:", e)[m
[32m+[m[32m    pending_alerts = [][m
[32m+[m[32m    last_summary_time = now[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Log tailing --------------------[m
[32m+[m[32masync def tail_log_loop(path: str, line_handler, poll_interval: float = 1.0):[m
[32m+[m[32m    """Tails a file and calls line_handler(line) for each new line. Async loop."""[m
[32m+[m[32m    # If no file, wait until exists[m
[32m+[m[32m    while not os.path.exists(path):[m
[32m+[m[32m        print(f"[TAIL] waiting for {path}")[m
[32m+[m[32m        await asyncio.sleep(2)[m
[32m+[m[32m    with open(path, "r", errors="ignore") as f:[m
[32m+[m[32m        # go to end[m
[32m+[m[32m        f.seek(0, os.SEEK_END)[m
[32m+[m[32m        while True:[m
[32m+[m[32m            where = f.tell()[m
[32m+[m[32m            line = f.readline()[m
[32m+[m[32m            if not line:[m
[32m+[m[32m                await asyncio.sleep(poll_interval)[m
[32m+[m[32m                f.seek(where)[m
[32m+[m[32m            else:[m
[32m+[m[32m                try:[m
[32m+[m[32m                    await line_handler(line.rstrip("\n"))[m
[32m+[m[32m                except Exception as e:[m
[32m+[m[32m                    print("[ERROR] handling log line:", e)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Handlers --------------------[m
[32m+[m[32masync def handle_auth_line(line: str):[m
[32m+[m[32m    """Detect SSH events from auth.log lines."""[m
[32m+[m[32m    # "Failed password for ... from 1.2.3.4 port 1234 ..."[m
[32m+[m[32m    m_failed = re.search(r"Failed password.*from (\d+\.\d+\.\d+\.\d+)", line)[m
[32m+[m[32m    m_invalid = re.search(r"Invalid user .* from (\d+\.\d+\.\d+\.\d+)", line)[m
[32m+[m[32m    m_accepted = re.search(r"Accepted .* for (\S+) from (\d+\.\d+\.\d+\.\d+)", line)[m
[32m+[m[32m    m_sudo = re.search(r"sudo: .*", line, flags=re.IGNORECASE)[m
[32m+[m[32m    now = datetime.utcnow()[m
[32m+[m
[32m+[m
[32m+[m[32m    if m_failed:[m
[32m+[m[32m        ip = m_failed.group(1)[m
[32m+[m[32m        dq = failed_attempts_by_ip[ip][m
[32m+[m[32m        dq.append(now)[m
[32m+[m[32m        # prune old[m
[32m+[m[32m        while dq and (now - dq[0]).total_seconds() > FAILED_ATTEMPT_WINDOW:[m
[32m+[m[32m            dq.popleft()[m
[32m+[m[32m        add_pending(f"Failed SSH attempt from {ip}. (Last {len(dq)} in window)")[m
[32m+[m[32m        if len(dq) >= FAILED_ATTEMPT_LIMIT:[m
[32m+[m[32m            add_pending(f"🚫 BLOCK TRIGGER: {ip} reached {len(dq)} failed attempts — consider blocking.")[m
[32m+[m[32m            dq.clear()[m
[32m+[m
[32m+[m
[32m+[m[32m    if m_invalid:[m
[32m+[m[32m        ip = m_invalid.group(1)[m
[32m+[m[32m        add_pending(f"🚫 Invalid user attempt from {ip}")[m
[32m+[m
[32m+[m
[32m+[m[32m    if m_accepted:[m
[32m+[m[32m        user, ip = m_accepted.groups()[m
[32m+[m[32m        add_pending(f"🔐 SSH login accepted: user={user} from {ip}")[m
[32m+[m[32m        # If root[m
[32m+[m[32m        if user.lower() in ("root", "administrator", "admin"):[m
[32m+[m[32m            add_pending(f"⚠️ Root login detected for {user} from {ip}")[m
[32m+[m
[32m+[m
[32m+[m[32m    if m_sudo:[m
[32m+[m[32m        add_pending("⚠️ sudo event detected in auth.log")[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Resource monitor --------------------[m
[32m+[m[32masync def resource_monitor_loop(application):[m
[32m+[m[32m    while True:[m
[32m+[m[32m        try:[m
[32m+[m[32m            cpu = psutil.cpu_percent(interval=1)[m
[32m+[m[32m            mem = psutil.virtual_memory().percent[m
[32m+[m[32m            disk = psutil.disk_usage("/").percent if os.name != "nt" else 0[m
[32m+[m[32m            if cpu >= CPU_THRESHOLD:[m
[32m+[m[32m                add_pending(f"⚠️ High CPU: {cpu:.1f}%")[m
[32m+[m[32m            if mem >= MEM_THRESHOLD:[m
[32m+[m[32m                add_pending(f"⚠️ High Memory: {mem:.1f}%")[m
[32m+[m[32m            if disk >= DISK_THRESHOLD:[m
[32m+[m[32m                add_pending(f"⚠️ High Disk: {disk:.1f}%")[m
[32m+[m[32m            await send_summary_if_due(application)[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            print("[ERROR] resource monitor:", e)[m
[32m+[m[32m        await asyncio.sleep(CHECK_INTERVAL)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Network usage --------------------[m
[32m+[m[32masync def network_monitor_loop(application):[m
[32m+[m[32m    iface = None[m
[32m+[m[32m    try:[m
[32m+[m[32m        stats = psutil.net_if_stats()[m
[32m+[m[32m        for name, s in stats.items():[m
[32m+[m[32m            if s.isup and name != "lo":[m
[32m+[m[32m                iface = name[m
[32m+[m[32m                break[m
[32m+[m[32m    except Exception:[m
[32m+[m[32m        iface = None[m
[32m+[m
[32m+[m
[32m+[m[32m    while True:[m
[32m+[m[32m        try:[m
[32m+[m[32m            if iface:[m
[32m+[m[32m                st = psutil.net_if_stats().get(iface)[m
[32m+[m[32m                if st and st.isup:[m
[32m+[m[32m                    link_speed = st.speed or 100[m
[32m+[m[32m                    io1 = psutil.net_io_counters(pernic=True)[iface][m
[32m+[m[32m                    await asyncio.sleep(1)[m
[32m+[m[32m                    io2 = psutil.net_io_counters(pernic=True)[iface][m
[32m+[m[32m                    sent = ((io2.bytes_sent - io1.bytes_sent) * 8) / 1e6[m
[32m+[m[32m                    recv = ((io2.bytes_recv - io1.bytes_recv) * 8) / 1e6[m
[32m+[m[32m                    total_pct = (sent + recv) / link_speed * 100 if link_speed > 0 else 0.0[m
[32m+[m[32m                    if total_pct >= NET_THRESHOLD:[m
[32m+[m[32m                        add_pending(f"⚠️ High network: {total_pct:.1f}% of {link_speed} Mbps (↑{sent:.2f} Mbps ↓{recv:.2f} Mbps)")[m
[32m+[m[32m            await send_summary_if_due(application)[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            print("[ERROR] network monitor:", e)[m
[32m+[m[32m        await asyncio.sleep(CHECK_INTERVAL)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Port scanner --------------------[m
[32m+[m[32masync def _scan_port(host: str, port: int, timeout=1.0):[m
[32m+[m[32m    """Try to connect (async) using threads (socket is blocking)."""[m
[32m+[m[32m    loop = asyncio.get_event_loop()[m
[32m+[m[32m    return await loop.run_in_executor(None, _sync_scan, host, port, timeout)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mdef _sync_scan(host, port, timeout):[m
[32m+[m[32m    try:[m
[32m+[m[32m        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)[m
[32m+[m[32m        s.settimeout(timeout)[m
[32m+[m[32m        s.connect((host, port))[m
[32m+[m[32m        s.close()[m
[32m+[m[32m        return True[m
[32m+[m[32m    except Exception:[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32masync def port_scan_loop(application, hosts=None, ports=None, port_range=None):[m
[32m+[m[32m    """Periodically scan specified ports on hosts and add alerts if open."""[m
[32m+[m[32m    hosts = hosts or ["127.0.0.1"][m
[32m+[m[32m    ports_to_scan = ports or PORTS_TO_SCAN[m
[32m+[m[32m    prange = port_range[m
[32m+[m[32m    while True:[m
[32m+[m[32m        try:[m
[32m+[m[32m            open_results = [][m
[32m+[m[32m            for h in hosts:[m
[32m+[m[32m                scan_list = list(ports_to_scan)[m
[32m+[m[32m                if prange:[m
[32m+[m[32m                    a, b = prange[m
[32m+[m[32m                    # be careful scanning very large ranges[m
[32m+[m[32m                    scan_list += list(range(a, min(b + 1, a + 2000)))[m
[32m+[m[32m                tasks = [_scan_port(h, p) for p in scan_list][m
[32m+[m[32m                results = await asyncio.gather(*tasks, return_exceptions=True)[m
[32m+[m[32m                for p, ok in zip(scan_list, results):[m
[32m+[m[32m                    if ok is True:[m
[32m+[m[32m                        open_results.append((h, p))[m
[32m+[m[32m            if open_results:[m
[32m+[m[32m                for h, p in open_results:[m
[32m+[m[32m                    add_pending(f"🔓 Port open: {h}:{p}")[m
[32m+[m[32m            await send_summary_if_due(application)[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            print("[ERROR] port scan:", e)[m
[32m+[m[32m        await asyncio.sleep(PORT_SCAN_INTERVAL)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Ping check --------------------[m
[32m+[m[32mdef _ping_host_sync(host):[m
[32m+[m[32m    """Ping using system ping. Returns True if host reachable."""[m
[32m+[m[32m    # Linux ping: -c 1 -W 2[m
[32m+[m[32m    try:[m
[32m+[m[32m        rc = os.system(f"ping -c 1 -W 2 {host} > /dev/null 2>&1")[m
[32m+[m[32m        return rc == 0[m
[32m+[m[32m    except Exception:[m
[32m+[m[32m        return False[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32masync def ping_loop(application, hosts=None):[m
[32m+[m[32m    hosts = hosts or PING_HOSTS[m
[32m+[m[32m    while True:[m
[32m+[m[32m        try:[m
[32m+[m[32m            for h in hosts:[m
[32m+[m[32m                ok = await asyncio.get_event_loop().run_in_executor(None, _ping_host_sync, h)[m
[32m+[m[32m                if not ok:[m
[32m+[m[32m                    add_pending(f"❌ Host down/unreachable: {h}")[m
[32m+[m[32m            await send_summary_if_due(application)[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            print("[ERROR] ping loop:", e)[m
[32m+[m[32m        await asyncio.sleep(60)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Public IP monitor --------------------[m
[32m+[m[32masync def public_ip_loop(application):[m
[32m+[m[32m    global last_public_ip[m
[32m+[m[32m    while True:[m
[32m+[m[32m        try:[m
[32m+[m[32m            async with aiohttp.ClientSession() as session:[m
[32m+[m[32m                async with session.get(PUBLIC_IP_URL, timeout=10) as resp:[m
[32m+[m[32m                    if resp.status == 200:[m
[32m+[m[32m                        ip = (await resp.text()).strip()[m
[32m+[m[32m                        if last_public_ip and ip != last_public_ip:[m
[32m+[m[32m                            add_pending(f"🌐 Public IP changed: {last_public_ip} -> {ip}")[m
[32m+[m[32m                        last_public_ip = ip[m
[32m+[m[32m            await send_summary_if_due(application)[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            print("[ERROR] public ip:", e)[m
[32m+[m[32m        await asyncio.sleep(PUBLIC_IP_CHECK_INTERVAL)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Suspicious processes --------------------[m
[32m+[m[32masync def suspicious_process_loop(application):[m
[32m+[m[32m    while True:[m
[32m+[m[32m        try:[m
[32m+[m[32m            procs = [p.info for p in psutil.process_iter(attrs=["pid", "name", "cmdline"])][m
[32m+[m[32m            for p in procs:[m
[32m+[m[32m                name = (p.get("name") or "").lower()[m
[32m+[m[32m                cmd = " ".join(p.get("cmdline") or []).lower()[m
[32m+[m[32m                for suspect in SUSPICIOUS_PROCESSES:[m
[32m+[m[32m                    if suspect in name or suspect in cmd:[m
[32m+[m[32m                        add_pending(f"⚠️ Suspicious process: {name} (pid={p.get('pid')}) cmd={cmd}")[m
[32m+[m[32m            await send_summary_if_due(application)[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            print("[ERROR] suspicious proc:", e)[m
[32m+[m[32m        await asyncio.sleep(60)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Telegram command handlers --------------------[m
[32m+[m[32masync def restricted(update: Update, context: ContextTypes.DEFAULT_TYPE, func):[m
[32m+[m[32m    if update.effective_user and update.effective_user.id != ADMIN_TELEGRAM_ID:[m
[32m+[m[32m        await update.message.reply_text("Unauthorized.")[m
[32m+[m[32m        return[m
[32m+[m[32m    return await func(update, context)[m
[32m+[m
[32m+[m
[32m+[m[32masync def start_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):[m
[32m+[m[32m    keyboard = [[m
[32m+[m[32m        [InlineKeyboardButton("Show System Status", callback_data='status')],[m
[32m+[m[32m        [InlineKeyboardButton("Pause Alerts", callback_data='snooze')],[m
[32m+[m[32m        [InlineKeyboardButton("Show Last 20 Log Lines", callback_data='tail')],[m
[32m+[m[32m        [InlineKeyboardButton("Run Local Port Scan", callback_data='scan')],[m
[32m+[m[32m    ][m
[32m+[m[32m    reply_markup = InlineKeyboardMarkup(keyboard)[m
[32m+[m[32m    await update.message.reply_text("Welcome to the Server Protector Bot!", reply_markup=reply_markup)[m
[32m+[m
[32m+[m[32masync def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):[m
[32m+[m[32m    keyboard = [[m
[32m+[m[32m        [InlineKeyboardButton("Show System Status", callback_data='status')],[m
[32m+[m[32m        [InlineKeyboardButton("Pause Alerts", callback_data='snooze')],[m
[32m+[m[32m        [InlineKeyboardButton("Show Last 20 Log Lines", callback_data='tail')],[m
[32m+[m[32m        [InlineKeyboardButton("Run Local Port Scan", callback_data='scan')],[m
[32m+[m[32m    ][m
[32m+[m[32m    reply_markup = InlineKeyboardMarkup(keyboard)[m
[32m+[m[32m    await update.message.reply_text("Available commands:", reply_markup=reply_markup)[m
[32m+[m
[32m+[m
[32m+[m[32masync def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):[m
[32m+[m[32m    query = update.callback_query[m
[32m+[m[32m    await query.answer()[m
[32m+[m
[32m+[m[32m    if query.data == 'status':[m
[32m+[m[32m        # Show system status (CPU, memory, disk usage)[m
[32m+[m[32m        cpu = psutil.cpu_percent()[m
[32m+[m[32m        mem = psutil.virtual_memory().percent[m
[32m+[m[32m        disk = psutil.disk_usage("/").percent if os.name != "nt" else 0[m
[32m+[m[32m        await query.edit_message_text(f"📊 CPU: {cpu:.1f}% | MEM: {mem:.1f}% | DISK: {disk:.1f}%")[m
[32m+[m
[32m+[m[32m    elif query.data == 'snooze':[m
[32m+[m[32m        # Snooze alerts for a period[m
[32m+[m[32m        await query.edit_message_text("Alerts snoozed for 15 minutes.")[m
[32m+[m
[32m+[m[32m    elif query.data == 'tail':[m
[32m+[m[32m        # Show last 20 log lines (you can modify to read actual logs)[m
[32m+[m[32m        await query.edit_message_text("Showing last 20 log lines...")[m
[32m+[m
[32m+[m[32m    elif query.data == 'scan':[m
[32m+[m[32m        # Run local port scan[m
[32m+[m[32m        await query.edit_message_text("Running local port scan...")[m
[32m+[m[32m        results = [][m
[32m+[m[32m        for p in PORTS_TO_SCAN:[m
[32m+[m[32m            ok = await _scan_port("127.0.0.1", p, timeout=0.7)[m
[32m+[m[32m            results.append(f"{p}: {'OPEN' if ok else 'closed'}")[m
[32m+[m[32m        await query.edit_message_text("\n".join(results))[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32masync def status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):[m
[32m+[m[32m    cpu = psutil.cpu_percent()[m
[32m+[m[32m    mem = psutil.virtual_memory().percent[m
[32m+[m[32m    disk = psutil.disk_usage("/").percent if os.name != "nt" else 0[m
[32m+[m[32m    await update.message.reply_text(f"📊 CPU: {cpu:.1f}% | MEM: {mem:.1f}% | DISK: {disk:.1f}%")[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32masync def snooze_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):[m
[32m+[m[32m    global snooze_until[m
[32m+[m[32m    if update.effective_user and update.effective_user.id != ADMIN_TELEGRAM_ID:[m
[32m+[m[32m        await update.message.reply_text("Unauthorized.")[m
[32m+[m[32m        return[m
[32m+[m[32m    try:[m
[32m+[m[32m        mins = int(context.args[0])[m
[32m+[m[32m        snooze_until = datetime.utcnow() + timedelta(minutes=mins)[m
[32m+[m[32m        await update.message.reply_text(f"🤫 Alerts snoozed for {mins} minutes.")[m
[32m+[m[32m    except Exception:[m
[32m+[m[32m        await update.message.reply_text("Usage: /snooze <minutes>")[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32masync def tail_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):[m
[32m+[m[32m    if update.effective_user and update.effective_user.id != ADMIN_TELEGRAM_ID:[m
[32m+[m[32m        await update.message.reply_text("Unauthorized.")[m
[32m+[m[32m        return[m
[32m+[m[32m    path = context.args[0] if context.args else AUTH_LOG[m
[32m+[m[32m    try:[m
[32m+[m[32m        with open(path, "r", errors="ignore") as f:[m
[32m+[m[32m            lines = f.readlines()[-20:][m
[32m+[m[32m        await update.message.reply_text("".join(lines) or "No data")[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        await update.message.reply_text(f"Error reading {path}: {e}")[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32masync def scan_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):[m
[32m+[m[32m    if update.effective_user and update.effective_user.id != ADMIN_TELEGRAM_ID:[m
[32m+[m[32m        await update.message.reply_text("Unauthorized.")[m
[32m+[m[32m        return[m
[32m+[m[32m    await update.message.reply_text("Running quick local port scan (small set)...")[m
[32m+[m[32m    # quick scan of configured ports on localhost[m
[32m+[m[32m    results = [][m
[32m+[m[32m    for p in PORTS_TO_SCAN:[m
[32m+[m[32m        ok = await _scan_port("127.0.0.1", p, timeout=0.7)[m
[32m+[m[32m        results.append(f"{p}: {'OPEN' if ok else 'closed'}")[m
[32m+[m[32m    await update.message.reply_text("\n".join(results))[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32masync def ports_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):[m
[32m+[m[32m    if update.effective_user and update.effective_user.id != ADMIN_TELEGRAM_ID:[m
[32m+[m[32m        await update.message.reply_text("Unauthorized.")[m
[32m+[m[32m        return[m
[32m+[m[32m    await update.message.reply_text("Port scan scheduled in background.")[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32masync def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):[m
[32m+[m[32m    msg = ([m
[32m+[m[32m        "Available commands:\n"[m
[32m+[m[32m        "/status - show system status\n"[m
[32m+[m[32m        "/snooze <mins> - pause alerts\n"[m
[32m+[m[32m        "/tail [file] - show last 20 lines of file\n"[m
[32m+[m[32m        "/scan - quick local port scan\n        "[m
[32m+[m[32m        "/help - this help"[m
[32m+[m[32m    )[m
[32m+[m[32m    await update.message.reply_text(msg)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# -------------------- Main (async) --------------------[m
[32m+[m[32masync def main():[m
[32m+[m[32m    application = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()[m
[32m+[m
[32m+[m[32m    # Register command handlers[m
[32m+[m[32m    application.add_handler(CommandHandler("status", status_cmd))[m
[32m+[m[32m    application.add_handler(CommandHandler("snooze", snooze_cmd))[m
[32m+[m[32m    application.add_handler(CommandHandler("tail", tail_cmd))[m
[32m+[m[32m    application.add_handler(CommandHandler("scan", scan_cmd))[m
[32m+[m[32m    application.add_handler(CommandHandler("ports", ports_cmd))[m
[32m+[m[32m    application.add_handler(CommandHandler("help", help_cmd))[m
[32m+[m
[32m+[m[32m    # Start background tasks[m
[32m+[m[32m    asyncio.create_task(tail_log_loop(AUTH_LOG, handle_auth_line, poll_interval=0.5))[m
[32m+[m[32m    asyncio.create_task(resource_monitor_loop(application))[m
[32m+[m[32m    asyncio.create_task(network_monitor_loop(application))[m
[32m+[m[32m    asyncio.create_task(port_scan_loop(application, hosts=["127.0.0.1"], ports=PORTS_TO_SCAN, port_range=None))[m
[32m+[m[32m    asyncio.create_task(ping_loop(application, hosts=PING_HOSTS))[m
[32m+[m[32m    asyncio.create_task(public_ip_loop(application))[m
[32m+[m[32m    asyncio.create_task(suspicious_process_loop(application))[m
[32m+[m
[32m+[m[32m    # Send 'connected' message to the admin[m
[32m+[m[32m    await application.bot.send_message(chat_id=ADMIN_TELEGRAM_ID, text="🤖 Server Protector Bot Connected ✅")[m
[32m+[m
[32m+[m[32m    # Start polling (will run until cancelled)[m
[32m+[m[32m    await application.run_polling()[m
[32m+[m
[32m+[m[32mif __name__ == "__main__":[m
[32m+[m[32m    try:[m
[32m+[m[32m        asyncio.run(main())  # Start the bot with the new async method[m
[32m+[m[32m    except KeyboardInterrupt:[m
[32m+[m[32m        print("Stopped by user.")[m
\ No newline at end of file[m
